---
title: "Java静态代码块用法及其运行机制"
date: 2018-09-24T16:39:50+08:00
draft: false
categories: ["Java相关"]
tags: ["Java","基础语法","面向对象","类加载"]
author: "Jason·Gan"
---
* 前言：前两天写了一段程序，本来想设计一个静态代码块，没想到因为不了解静态代码块的编译机制栽了坑，现在来学习一下  

## 类的运行步骤  
* 装载  
* 链接  
* 初始化  

### 装载  
 - 1.通过类型的完全限定名，产生一个代表该类型的二进制数据流  
 - 2.解析这个二进制数据流为方法区内的内部数据结  
 - 3.创建一个表示该类型的java.lang.Class类的实例  
 - 4.如果一个类装载器在预先装载的时遇到缺失或错误的class文件，它需要等到程序首次主动使用该类时才报告错误。  

### 链接  
 - 1.验证，确认类型符合Java语言的语义，检查各个类之间的二进制兼容性(比如final的类不用拥有子类等)，另外还需要进行符号引用的验证。
 * 2.准备，Java虚拟机为类变量分配内存，设置默认初始值。
 * 3.解析(可选的) ，在类型的常量池中寻找类，接口，字段和方法的符号引用，把这些符号引用替换成直接引用的过程。  

### 初始化  
* 1. 当创建某个类的新实例时（如通过new或者反射，克隆，反序列化等）  
* 2. 当调用某个类的静态方法时  
* 3. 当使用某个类或接口的静态字段时  
* 4. 当调用Java API中的某些反射方法时，比如类Class中的方法，或者java.lang.reflect中的类的方法时  
* 5. 当初始化某个子类时，也会调用父类的构造方法，  
* 6. 当虚拟机启动某个被标明为启动类的类（即包含main方法的那个类）  

## 测试  

* 测试用例：  
```

public class StaticLearning {
    public static void main(String[] args) {
        new Child();
    }
    static{
        System.out.println("父类---静态代码块");
    }
    {
        System.out.println("父类---非静态代码块");
    }
    StaticLearning(){
        System.out.println("父类---构造函数");
    }
}

class Child extends StaticLearning{
    static{
        System.out.println("子类---静态代码块");

    }
    {
        System.out.println("子类---非静态代码块");
    }
    Child(){
        System.out.println("子类---构造函数");
    }

}  
```  

* 可以先思考一下，输出结果是怎么样的，这个输出结果即是JVM运行时，对类的操作动态  
* 运行结果，如下图：  
![](/image/staticLearning/1.jpg)  

---  
* 结果表明：  
* 1. 类加载时，先加载父类的静态代码块并只运行一次  
* 2. 再加载子类的静态代码块并只运行一次
* 3. 再初始化父类非静态代码块  
* 4. 再初始化父类的构造函数  
* 5. 在初始化子类的非静态代码块  
* 6. 最后初始化子类的构造函数  

最后，其实静态代码块不是一定在非静态代码块前运行，因为如果同时静态代码块的话，按顺序先后加载，但是如果是在静态块或者静态成员里加载了非静态的成员的话，非静态成员就可以先初始化了。  


  





  


